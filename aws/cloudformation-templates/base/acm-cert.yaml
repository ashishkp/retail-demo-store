AWSTemplateFormatVersion: 2010-09-09

Description: >
    This template deploys the SSL/TLS selfsigned certificate for Retail Demo Store ELBs to ACM
    Author: Ronak Shah <ronakbsh@amazon.com>
 
Resources:
    ACMARNParameter:
        Type: AWS::SSM::Parameter
        Properties:
          Name: /retaildemostore/acm-arn
          Type: String 
          Value: Dummy
          Description: Retail Demo Store ACM Arn 
          
    ACMImportCertLambdaFunLogGroup:
        Type: AWS::Logs::LogGroup
        Properties:
          LogGroupName: !Sub /aws/lambda/${ACMimportCertLambdaFunction}
          RetentionInDays: 3
          
    ACMimportCertLambdaLambdaLayer1:
        Type: AWS::Lambda::LayerVersion
        Properties:
          CompatibleArchitectures:
            - x86_64
          CompatibleRuntimes:
            - python3.9
          Content:
            S3Bucket: lambda-layer-ptelzp
            S3Key: lambda-layer.zip
          LayerName: "OpenSSL-Python3-9-Layer1"
        
    ACMimportCertLambdaFunction:
        Type: AWS::Lambda::Function
        DependsOn: ACMARNParameter        
        Properties:
          Description: 'Retail Demo Store acm-import-certificate function that returns ARN for imported certificate'
          Code:
            ZipFile: |
              import boto3
              import cfnresponse
              import random
              from OpenSSL import crypto
              from botocore.exceptions import ClientError
              
              response_data = {}

              acm_client = boto3.client('acm')
              ssm_client = boto3.client('ssm')
              

              def handler(event, context):
                response_status = cfnresponse.SUCCESS
                acmarn_param_name = '/retaildemostore/acm-arn';
                
                try:
                    
                    if event['RequestType'] == 'Create':
                    
                        # Create CA for Self-signed Certificate
              
                        ca_key = crypto.PKey()
                        ca_key.generate_key(crypto.TYPE_RSA, 2048)
                        ca_cert = crypto.X509()
                        ca_cert.set_version(2)
                        ca_cert.set_serial_number(random.randrange(100000))
                        ca_subj = ca_cert.get_subject()
                        ca_subj.C = "US"
                        ca_subj.ST = "California"
                        ca_subj.L = "San Francisco"
                        ca_subj.O = "MyOrganization"
                        ca_subj.OU = "MyOrganizationalUnit"
                        ca_subj.CN = "My own Root CA"
                        ca_cert.add_extensions([
                            crypto.X509Extension(b"subjectKeyIdentifier", False, b"hash", subject=ca_cert),
                        ])
                        ca_cert.add_extensions([
                            crypto.X509Extension(b"authorityKeyIdentifier", False, b"keyid:always", issuer=ca_cert),
                        ])
                        ca_cert.add_extensions([
                            crypto.X509Extension(b"basicConstraints", False, b"CA:TRUE"),
                            crypto.X509Extension(b"keyUsage", False, b"keyCertSign, cRLSign"),
                        ])
                        ca_cert.set_issuer(ca_subj)
                        ca_cert.set_pubkey(ca_key)
                        ca_cert.sign(ca_key, 'sha256')
                        ca_cert.gmtime_adj_notBefore(0)
                        ca_cert.gmtime_adj_notAfter(10*365*24*60*60)
                        ca_certifictate_pem = crypto.dump_certificate(crypto.FILETYPE_PEM, ca_cert).decode('utf-8')

                        # Create Self-Signed Certificate
                        client_key = crypto.PKey()
                        client_key.generate_key(crypto.TYPE_RSA, 2048)
                        client_cert = crypto.X509()
                        client_cert.set_version(2)
                        client_cert.set_serial_number(random.randrange(100000))
                        client_subj = client_cert.get_subject()
                        client_subj.C = "US"
                        client_subj.ST = "California"
                        client_subj.L = "San Francisco"
                        client_subj.O = "MyOrganization"
                        client_subj.OU = "MyOrganizationalUnit"
                        client_subj.CN = "retail-demo-alb.example.com"
                        client_cert.add_extensions([
                            crypto.X509Extension(b"basicConstraints", False, b"CA:FALSE"),
                            crypto.X509Extension(b"subjectKeyIdentifier", False, b"hash", subject=client_cert),
                        ])
                        client_cert.add_extensions([
                            crypto.X509Extension(b"authorityKeyIdentifier", False, b"keyid:always", issuer=ca_cert),
                            crypto.X509Extension(b"extendedKeyUsage", False, b"serverAuth"),
                            crypto.X509Extension(b"keyUsage", False, b"digitalSignature"),
                        ])
                        client_cert.add_extensions([
                            crypto.X509Extension(b'subjectAltName', False,
                                ','.join([
                                    'DNS:retail-demo-alb.example.com'
                        ]).encode())])
                        client_cert.set_issuer(ca_subj)
                        client_cert.set_pubkey(client_key)
                        client_cert.gmtime_adj_notBefore(0)
                        client_cert.gmtime_adj_notAfter(9*365*24*60*60)
                        client_cert.sign(ca_key, 'sha256')
                          
                        certifictate_pem = crypto.dump_certificate(crypto.FILETYPE_PEM, client_cert).decode('utf-8')
                        private_key_pem = crypto.dump_privatekey(crypto.FILETYPE_PEM, client_key).decode('utf-8')
                        
                        my_response = acm_client.import_certificate(
                          Certificate=certifictate_pem,
                          PrivateKey=private_key_pem,
                          CertificateChain=ca_certifictate_pem,
                          Tags=[
                              {
                              'Key': 'ACM',
                              'Value': 'retailDemoStore'
                              },
                          ]
                        )
                        
                        # Overwrite Certificate ARN value in SSM Parameter
                        acmarn_parameter = ssm_client.put_parameter(
                            Name=acmarn_param_name,
                            Value=my_response['CertificateArn'],
                            Type='String',
                            Overwrite=True)
                            
                        response_data['certificate_arn'] = my_response['CertificateArn']
                        response_data['Message'] = "Resource creation succeeded"
                    elif event['RequestType'] == 'Update':
                        response_data['Message'] = "Resource update succeeded"
                    elif event['RequestType'] == 'Delete':
                        # Delete the cert from ACM, assumes all attachments are already removed.
                        
                        # Retrieve ACM ARN from Parameter store
                        acmarn_parameter = ssm_client.get_parameter(Name=acmarn_param_name)
                        
                        # Delete ACM
                        my_response = acm_client.delete_certificate(
                            CertificateArn=acmarn_parameter['Parameter']['Value']
                        )
                        
                        response_data['Message'] = "Resource deletion succeeded"                      
                except ClientError as e:
                  print("Error: " + str(e))
                  response_status = cfnresponse.FAILED
                  response_data['Message'] = "Resource {} failed: {}".format(event['RequestType'], e)

                cfnresponse.send(event, context, response_status, response_data)
          Handler: index.handler            
          Runtime: python3.9
          Timeout: 120
          Role: !GetAtt ACMimportCertLambdaExecutionRole.Arn
          Layers:
            - !Ref ACMimportCertLambdaLambdaLayer1
        
    ACMimportCertLambdaExecutionRole:
        Type: 'AWS::IAM::Role'
        Properties:
          AssumeRolePolicyDocument:
            Version: 2012-10-17
            Statement:
            - Effect: Allow
              Principal:
                Service:
                  - lambda.amazonaws.com
              Action:
                - 'sts:AssumeRole'    
          Path: /
          Policies:
              - PolicyName: CustomLogAndSSMPolicy
                PolicyDocument:
                  Version: 2012-10-17
                  Statement:
                  - Effect: Allow
                    Action:
                      - logs:CreateLogStream
                      - logs:DescribeLogStreams
                      - logs:PutLogEvents
                    Resource:
                      - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:*'
                  - Effect: Allow
                    Action:
                      - ssm:GetParameter
                      - ssm:PutParameter
                    Resource: '*'
          ManagedPolicyArns:
            - 'arn:aws:iam::aws:policy/AWSCertificateManagerFullAccess'
            
    ACMimportCertLambdaFunctionExecution:
        Type: Custom::CustomLambdaACMCert
        Version: "1.0"
        Properties:
            ServiceToken: !GetAtt ACMimportCertLambdaFunction.Arn        

Outputs:
  ACMimportCertLambdaFunctionArn:
    Description: Lambda function ARN for ACM self-signed cert function
    Value: !GetAtt ACMimportCertLambdaFunction.Arn
  ACMimportCertArn:
    Description: ACM self signed cert Arn to use in ELB listener
    Value: !GetAtt ACMimportCertLambdaFunctionExecution.certificate_arn			
